## 方法覆盖和多态


## 方法覆盖
> 回顾满足什么条件构成方法重载？
> 1. 在同一个类中
> 2. 方法名相同
> 3. 参数列表不同（个数，顺序、类型）
> 什么时候使用方法覆盖?
> 1. 子类继承父类之后，继承过来的方法无法满足当前子类的业务需求时
> 2. 当子类对父类继承过来的方法进行覆盖后，子类对象调用该方法的时候，一定执行覆盖后的方法
> 满足什么条件构成方法覆盖?
> 1. 两个类必须有继承关系
> 2. 重写之后的方法和之前的方法具有相同的（返回值类型，方法名，形参列表）
> 3. 访问权限不能更低，可以更高
> 4. 重写之后的方法不能比之前抛出更多的异常，可以更少
> Tips(几个注意事项)
> 1. 方法覆盖只是针对于方法，和属性无关
> 2. 私有方法无法覆盖
> 3. 构造方法不能被继承，所以不能被覆盖
> 4. 方法覆盖只针对实例方法，静态方法覆盖没有意义


### 多态
> 1. 向上转型(子--->父)   (类似基本数据类型的自动类型转换)
> 2. 向下转型(父--->子)   (类似基本数据类型的强制类型转换，需要加强制类型转换符)

> java中允许向上转型   也允许向下转型
> 无论是向上转型还是向下转型  没有继承关系  编译器会报错

> 什么是多态？ 多种形态，多种状态


#### 向上转型
> Animal a2 = new Cat();
> a2.move();
> java程序分为编译阶段和运行阶段
#### 编译阶段
> 1. 对于编译器来说，编译器只知道a2的类型是Animal
> 2. 所以编译器在检查语法的时候，会去Animal.class字节码文件中找move方法
> 3. 找到了，绑定上move方法，编译通过，静态绑定成功
#### 运行阶段
> 1. 运行阶段的时候，堆内存中创建的java对象是Cat对象，
> 2. 所以move执行的时候，真正参与的对象是Cat
> 3. 所以运行阶段会动态执行Cat对象的move方法(动态绑定)


> 多态指的是:
> 1. 父类型引用指向子类型对象
> 2. 包括编译阶段和运行阶段
> 3. 编译阶段: 绑定父类的方法
> 4. 运行阶段: 动态绑定子类型对象的方法
>  以上  多种形态！


#### 向下转型
> a5是Animal类型  转成Cat  Animal和Cat有继承关系
> Animal a5 = new Cat();
> Cat x = (Cat) a5;
> a5.catchMouse();

> 什么时候使用向下转型?
> 不要随便强制类型转换 
> 当你需要访问的是子类对象特有的方法时必须进行向下转型

> 向下转型有风险吗？
> Animal a6 = new Bird(); // 表面上a6是一个Animal,运行的时候实际上是一只鸟
> Cat y = (Cat)a6;      //
> y.catchMouse();   // 编译没问题  运行报错
> 运行阶段，堆内存实际创建的对象是 Bird对象
> Bird转Cat 会报异常！
> 如何避免向下转型出现的问题？
> 使用关键字 instanceof 
> if(a6 instanceof Cat) { 
>    Cat y = (Cat) a6;
>    y.catchMouse(); 
> }
> 但凡是向下转向都需使用   instanceof 运算符进行判断！


#### 在覆盖的时候 返回值类型可以不一样吗？
> 1. 对于返回值是基本数据类型来说，必须一致
> 2. 对于返回值类型是引用数据类型来说，重写之后返回值类型可以变得更小(意义不大，实际开发中不这样写)
