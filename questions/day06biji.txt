## this
> 1. this 是一个关键字 是一个引用 保存内存地址指向自身
> 2. this可以使用在实例方法中 也可以使用在构造方法中
> 3. this不能使用在静态方法中
> 4. 区分局部变量和实例变量时不能省略this
> 5. this()这种语法只能出现在构造方法第一行，表示当前构造函数调用本类的其它函数，目的时代码复用


###  总结
> 类体{
    实例变量;
    实例方法;

    静态变量;
    静态方法;

    构造方法;

    静态代码块;
    实例代码块;

    方法(){
        局部变量;
    }
}

> 2. 所有的实例相关的都是先创建对象
> 3. 所有的静态相关的都是直接采用"类名."来访问 （也可以对象.来访问 不推荐）
> 4. 同类总  this.可以省略   类名.可以省略



## 继承

### 继承的基本作用:
> 1. 子类继承父类，代码可以得到复用
> 2. 继承是方法覆盖 和多态的基础
### 继承的相关特性
> 1. B类继承A类 A类称之为 超类 父类 基类 B类称之为子类 派生类 扩展类
> 2. java中只支持单继承
> 3. 可以间接继承 C继承B  B继承A  C间接继承A
> 4. java中规定,子类继承父类，除构造方法不能继承外,剩下都可以继承，但是私有的属性无法在子类中直接访问
> 5. 如果一个类没有显式的继承任何类，则默认继承Object类
> 6. 继承也存在缺店  子类和父类耦合度很高 父类改变 直接影响到子类





## 十大排序算法

### 总览 
> 算法名称  |   平均时间复杂度  |  最好情况  |   最坏情况  |   空间复杂度    
> 冒泡排序  |       O(n^2)     |    O(n)    |    O(n^2)  |     O(1)
> 选择排序  |       O(n^2)     |    O(n^2)  |    O(n^2)  |     O(1) 
> 希尔排序  |       O(n^1.3)   |    O(n)    |    O(n^2)  |     O(1)

### 1. 冒泡排序
> 算法描述
> 1. 比较相临的元素。如果第一个比第二个大，就交换它们两个
> 2. 对每一对相临元素作同样的工作，从开始第一对到结尾最后一对
> 3. 针对所有的元素重复以上的步骤，除了最后一个
> 4. 重复步骤1，2，3，直到排序完成
### 2. 选择排序
> 算法描述
> 1. 初始状态: 无序区为R[1..n],有序区为空
> 2. 第i次排序(i=1...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i...n]
> 3. 从无序区中选出最小的放在无序区的第一位
> 4. 此时 有序区 为[1...i]和[i+1...n]
> 5. 重复2，3，4步骤 当n-1次结束时  排序完成
### 3. 插入排序
> 1. 从第一个元素开始，该元素可以认为已经被排序
> 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
> 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
> 4. 重复步骤(3),直到找到已排序的元素小于或者等于新元素的位置；
> 5. 将新元素插入到该位置后
> 6. 重复2-5

### 待更新